Цель: реализовать сайт на подобии VK.
Функционал:
- Аутентификация
- Профиль и его редактирование
- Страница со всеми пользователями, возможность просматривать чужие профили
- Публикация постов, редактирование, удаление

Доп. функционал:
- пагинация, поиск, фильтрация



Ход разработки:
21.06.2023:
1) Создал базовую структуру работы с БД: файл `lib/db.ts` для подключения к БД, модели поста и юзера.
2) приступил к созданию роутов API для регистрации и авторизации. Здесь подробнее: (хоть я уже и делал)
2.1 - Регистрация. Она строится таким образом: мы отправляем данные в API (из формы регистрации) -> затем проверяем в API, пришли ли эти данные -> переведим их в читаемый вид -> проверяем, есть ли уже пользователи с такой почтой -> кэшируем пароль и создаём новый документ пользователя -> сохраняем в БД данные пользователя -> редиректим на страницу входа.
2.2 - Авторизация. Здесь немного сложнее, т.к. подключаются куки. Эта часть API принимает данные из формы -> также проверяет, что всё передано -> проверяем, есть ли юзер с такой почтой -> сравниваем пароли из формы и БД -> генерируем токены доступа и обновления -> токен доступа сохраняется в куки, а токен обновления в куки и в БД.
3) Авторизация и регистрация реализованы, проверил работу через Postman. Дополнительно делаю выход. Для него нужно просто удалить токены из куки.


22.06.2023:
1) Реализовал UI для регистрации и авторизации
2) Дополнительно подготовлен Header-компонент с условным рендером кнопки авторизации/регистрации/выхода. Реализован так: Через хук узнаём актуальный роут и рендерим ссылки на страницах регистрации и авторизации для взаимного перехода. Также более глобальное условие: проверка наличия токена. Если он есть, то выводим кнопку `logout`, а иначе - что-то из ссылок на регистрацию/авторизацию.
3) Все формы привожу в действие. Форма регистрации отлично сохраняет данные на сервере. Форма авторизации завершается со статусом 200, но куки не сохраняются. Проблему обозначу тут, как найду: (Оказывается, что куки в новой версии Next устаналиваются через NextResponse)
4) Нужно выводить ошибку, почему не проходит авторизация / регистрация. Создадим стейт для каждой формы.
5) Действия 3 и 4 вызвали ряд широких изменений. Пришлось обе формы переделать в клиентские компоненты. Всё потому, что нужно следить за 2 стейтами (ошибка + лоадер отправки данных). Также Мне пришлось убрать файлы `actions.ts` для форм, т.к. они работали с куки на уровне сервера, не устанавливая их на клиенте. Поэтому я не видел токены в браузере во время авторизации, но видел во время отправки запроса через Postman.
Код стал менее удобным в каждой форме, но он понятный и обслуживаемый. Отправка данных может возвращать в UI ошибку с объяснением, что не так. Также кнопка отправки меняется в зависимости от состояния отпарвки запроса.
6) Авторизация выполнена, но пропала кнопка выхода. Решил проблему: оказалось, что я неправильно указал имя свойства из ответа сервера .__.
7) Не работает logout. Скорее всего из-за того, что опять конфликт сервера/клиента. Сейчас переобородую для использования на клиенте. Также есть незначительная проблема: после авторизации в хэдере куки не обновляются без перезагрузки страницы, поэтому кнопка выхода просто не появляется, если не перезагрузить страницу.
Logout заработал, но вот обновление `isAuth` оказалось куда сложнее. Можно подключить провайдер, но это слишком громоздко для такой задачи сейчас. Буду искать другие способы. А пока сохраню проект на GitHub.
8) Я добавил middleware-обработчик, который не давал доступа к любым страницам кроме авторизации и регистрации, если неавторизован. И наоборот не пускал на эти страницы, если уже есть авторизация. Проблема возникла: обработчик захватил ещё и API-маршруты, поэтому он стал блочить запросы, что привело к тому, что они не работали. Поправил, добавив исключение. Теперь всё работает.

Что нужно сделать далее?
- Страница "friends". Логика: запрос всех юзеров, их рендер, динамические пути к их профилям.
- страница "profile". Переход с "friends". Нужно продумать условный рендер для шапки. Чтобы страницы других пользователей мы могли только просматривать, а свою - редактировать. 

23.06.2025
1) Берусь за подключение refresh-токена. В прошлом проекте логика была реализована довольно плохо. Сейчас попробую через отдельный axios-инстанс.

24.06.2025
1) С инстансом ничего не вышло, пробую другие варианты.
Всё удалось: оказалось, что axios-instance используется только для работы с API на клиенте. В middleware же логика другая: мы получаем куки -> проверяем, есть ли токен доступа (ТД) -> если есть, то сверяем и редиректим со страниц авторизации -> если нет ТД, то проверяем токен обновления (ТО) -> если есть, то сверяем его и генерим новый ТД, далее редиректим -> если нет ТО и ТД, а страница блока auth, то даём доступ -> также просто редиректим на страницу авторизации, если нет валидных токенов (если мы оказались на странице не блока auth без токенов).
Логика тяжёлая, но рабочая.
2) Перед созданием страницы с пользователями (друзьями) добавил aside-меню с навигацией.
3) Создал 2 блока на странице друзей. Основной с контентом и правое меню для фильтрации и т.д.
4) В VK контент в основном блоке меняется через правое меню, которое меняет query-запрос. Для этого создал отдельный клиентский компонент TabButton, который принимает label (текст кнопки) и value (маршрут). Через useSearchParams определяю активный query-запрос (по умолчанию поставил на всех друзей в AsideMenu). Через useRouter меняю запросы по нажатию. Осталось менять содержимое основного блока. Для этого создал ещё один клиентский компонент FriendsSectionsSwitcher, который рендерит основной контент в зависимости от активного query-запроса.
Также сделал выделение кнопки активного роута, как в этом блоке, так и в общем меню навигации.
5) На странице поиска отрендерил импровизированный массив. Если нет данных, то выводится сообщение. Выводим основную информацию + кнопку "Добавить". Пока что просто консолит, не конфликтует с обёрткой карточки, которая ведёт на профиль юзера.

Что дальше?
- создать динамическую страницу юзера
- продумать, как обособлять нашу личную страницу. Как вариант, можно брать из куки payload id юзера и сравнивать. Но это слишком жирно по ресурсам будет. Также стоит вопрос роута - куда редиректить, если открываем профиль чужого человека. Странно, если в сайдбаре будет подсвечиваться линк профиля.

25.06.2025
1) Работаю над страницей юзера. Создал блок Инфо, где собрана базовая информация. Подзапарился над UI и теперь есть 2 кнопки с анимацией: Сообщение и Добавить в друзья (контекстное меню).
2) Вынес в отдельный компонент этот мини-блок. Решил перевести все стили в CVA.


26.06.2025
1) Хочу везде добавить адаптив, потому что потом будет труднее всё это подключать. Сначала сделал боковое меню скрывающимся. Пришлось создавать обёртку для всего содержимого корневого layout, чтобы управлять состоянием компонента меню через другой компонент - хэдер.
2) Добавляю адаптив на все страницы.
3) Перешёл к созданию новых блоков для Юзера. Кнопки взаимодействия (сообщение, добавить в друзья) вынес в другой блок, где также отобразил количество подписчиков.
4) Создал блок для постов. Также создал сам компонент поста. Через нейронку создал функцию, которая прогоняет через себя дату и выдаёт красивый вариант без года / с указанием по типу "сегодня/вчера" и т.д. Нужно будет улучшить её, чтобы посты за предыдущие года имели полную дату.
5) Исправляю все ошибки типов, делаю коммит и выкладываю на Vercel.

27.06.2025
1) Пробую подключить БД к странице с поиском пользователей. Для этого создал дополнительный роут api/users/route.ts, где просто запрашиваю всех пользователей.
2) Добавил в общий layout отображение поиска, если сейчас открыта страница поиска.
3) В БД добавил 20 записей, теперь на странице поиска много пользователей, но нужна пагинация для комфортного просмотра. Делаю пагинацию.
4) Далее нужно переводить на страницу пользователя и отображать его данные. Для этого будем брать id из URL, а потом с помощью API брать нужного юзера.

29.06.2025
1) Пагинация сделана. Для реализации использовал готовый компонент из своей библиотеки. На сервере я обрабатываю запрос к API, который теперь содержит параметры страницы и лимита.
2) Пробую реализовать поиск. Получилось с помощью создания объекта запроса query. Внутрь поместил условия поиска и использовал в запросе к серверу.
3) Добавил debounce функцию (хук) для оптимизации работы поиска (меньше запросов к серверу).
4) Теперь берусь за страницу пользователя. Нужно запрашивать во время рендера данные пользователя, сравнивать id оттуда с id из cookie, чтобы понимать, моя это страница или нет.
4.1 - осознал проблему во время получния id активного пользователя. Если токен умрёт прямо во время работы, то запрос не будет выполнен нормально. Тут нужно когда-то подключить перехватчик.

30.06.2025
1) Обновил модель пользователя для апгрейда профиля.
2) Возникла проблема с формой после обновления модели. Я использовал в форме регистрации action с клиентской функцией, когда action является серверным атрибутом, который используется для указания URL, куда отправляется форма. Правильнее было обернуть в функцию в onSubmitHandler и вызывать её там.
3) Добавил логику для открытия своей страницы во время нажатия в менюшке "Profile". Для этого прокинул с корневого layout ID юзера из payload.
4) Возникла проблема с рендером количества подписчиков. Типы данных сложно состыковать, т.к. приходит ObjectID[] массив, но в таком виде не хочет передаваться нормально. Пока что передаю всё как строки.

5) сделал коммит, взялся за другие блоки в FriendsSearch. У меня возникла мысль, что запихивать логику отображения своих друзей и просмотра чужих друзей с одного маршрута идея так себе. Лучше всего будет открывать отдельный маршрут для просмотра, даже есть вариант делать его в slug, чтобы появлялся попап-блок. Здесь же просто реализую всё, что относится к моему профилю.
6) Через нейронку подтянул путь для списка друзей пользователя. Всё работает отлично.
7) Нужно сделать то же самое, но для страницы с заявками. Тут всё не так сложно, запрос аналогичен списку друзей. Просто подтягивать будем сразу 2 массива: заявки к тебе в друзья и свои заявки.

01.07.2025
1) Всем документам в коллекции пользователей добавил новое поле `myFriendsRequests`. Очень долго сидел, пытаясь сделать это через Mongo Atlas, но в итоге получилось только через MongoDB Compass.
2) Делаю страницу заявок. Предполагается, что должно быть дополнительное меню в правой части, которое позволит переключаться между своими заявками и заявками, которые пришли тебе. 
3) Добавил это меню в компонент кнопки. Теперь два доп. элемента появляются прямо под ней, если выбраны "Заявки". Остаётся лишь делать запрос к серверу, который будет совершаться вновь, если меняем субменю.
Ещё подумал о том, что неплохо было бы вынести все ранее созданные элементы в компоненты, т.к. код дублируется очень много.
4) Вынес из карточку пользователя в компонент, но пришлось настраивать логику отображения содержания, т.к. там замудрённые условия. 

5) Все роуты работают, теперь страница с друзьями отображает всевозможные списки пользователей. Нужно только добавить логику кнопкам для добавления/удаления друзей.
6) Вынес функции для получения списка пользователей/запросов в отдельную утилиту `fetchFriendsLists.utils`. Делаю коммит.